//// Wrapper class for each and every value of the input array,
//// to store the original index position of each value, before we merge sort the array
//
//import java.util.*;
//public class Solution{
//    public class pair {
//        int value;
//        int index;
//
//        public pair(int value, int index) {
//            this.value = value;
//            this.index = index;
//        }
//
//    }
//
//    public List<Integer> countSmaller(int[] arr) {
//        if (arr == null || arr.length == 0) return new LinkedList<Integer>();
//        int n = arr.length;
//        int[] count_smaller = new int[n];
//
//        pair[] pairs = new pair[n];
//        for (int i = 0; i < n; ++i) pairs[i] = new pair(arr[i], i);
//
//        mergeSortAndCount(pairs, 0, n - 1, count_smaller);
//
//        // notice we don't care about the sorted array after merge sort finishes.
//        // we only wanted the result counts, generated by running merge sort
//        List<Integer> list = new LinkedList<Integer>();
//
//        for (int i : count_smaller)
//        {
//            list.add(i);
//        }
//        return list;
//
//    }
//
//    private void mergeSortAndCount(pair[] pairs, int start, int end, int[] count_smaller) {
//
//        if (start >= end) return;
//
//        int mid = (start + end) / 2;
//        mergeSortAndCount(pairs, start, mid, count_smaller);
//        mergeSortAndCount(pairs, mid + 1, end, count_smaller);
//
//        // left subarray start...mid
//        // right subarray mid+1...end
//        int i = start;
//        int j = mid + 1;
//        LinkedList<pair> merged = new LinkedList<pair>();
//        int smallerNumbers = 0;
//        while (i < mid + 1 && j <= end) {
//            if (pairs[i].value > pairs[j].value) {
//                // this code block is exactly what the problem is asking us for:
//                // a number from the right side of the original input array, is smaller
//                // than a number from the left side
//                //
//                // within this code block,
//                // nums[rightPos] is smaller than the start of the left sub-array.
//                // Since left sub-array is already sorted,
//                // nums[rightPos] must also be smaller than the entire remaining left sub-array
//                ++smallerNumbers;
//
//                // continue with normal merge sort, merge
//                merged.add(pairs[j]);
//                ++j;
//            }
//            else {
//                // a number from left side of array, is smaller than a number from
//                // right side of array
//                count_smaller[pairs[i].index] += smallerNumbers;
//
//                // Continue with normal merge sort
//                merged.add(pairs[i]);
//                ++i;
//            }
//        }
//
//        // part of normal merge sort, if either left or right sub-array is not empty,
//        // move all remaining elements into merged result
//        while (i < mid + 1) {
//            count_smaller[pairs[i].index] += smallerNumbers;
//
//            merged.add(pairs[i]);
//            ++i;
//        }
//        while (j <= end) {
//            merged.add(pairs[j]);
//            ++j;
//        }
//
//        // part of normal merge sort
//        // copy back merged result into array
//        int pos = start;
//        for (pair m : merged) {
//            pairs[pos] = m;
//            ++pos;
//        }
//    }
//}